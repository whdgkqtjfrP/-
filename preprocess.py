# -*- coding: utf-8 -*-
"""preprocess.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oPoHkiqOWFyKh3u3HnxIBiH9unIAG8j0
"""

from scapy.all import rdpcap

def extract_tcp_features(pcap_file):
    packets = rdpcap(pcap_file)
    tcp_data = []
    for pkt in packets:
        if pkt.haslayer("IP") and pkt.haslayer("TCP"):
            packet_info = {
                "src": pkt["IP"].src,
                "dst": pkt["IP"].dst,
                "sport": pkt["TCP"].sport,
                "dport": pkt["TCP"].dport,
                "seq": pkt["TCP"].seq,
                "ack": pkt["TCP"].ack,
                "flags": pkt["TCP"].flags,
                "window": pkt["TCP"].window,
                "len": len(pkt),
                "frame_time": pkt.time
            }
            tcp_data.append(packet_info)
    return pd.DataFrame(tcp_data)

#데이터 정규화 및 전처리
from sklearn.preprocessing import MinMaxScaler, StandardScaler
import ipaddress

def preprocess_tcp_data(df):
    df = df.sort_values(by="frame_time").reset_index(drop=True) #시간순 정렬
    # IP 주소를 정수로 변환
    df["src"] = df["src"].apply(lambda x: int(ipaddress.IPv4Address(x)))
    df["dst"] = df["dst"].apply(lambda x: int(ipaddress.IPv4Address(x)))

    # IP 주소 정규화
    scaler_ip = MinMaxScaler()
    df[["src", "dst"]] = scaler_ip.fit_transform(df[["src", "dst"]])

    # 포트 번호 정규화
    scaler_ports = MinMaxScaler()
    df[["sport", "dport"]] = scaler_ports.fit_transform(df[["sport", "dport"]])

    # 윈도우 크기 및 패킷 길이 정규화
    scaler_size = MinMaxScaler()
    df[["window", "len"]] = scaler_size.fit_transform(df[["window", "len"]])

    # 시퀀스 및 ACK 번호 정규화
    df["seq_ack_diff"] = df["ack"] - df["seq"]
    df["seq_diff"] = df["seq"].diff().fillna(0)
    scaler = MinMaxScaler()
    df[["seq_ack_diff", "seq_diff"]] = scaler.fit_transform(df[["seq_ack_diff", "seq_diff"]])
    df.drop(columns=["seq", "ack"], inplace=True)

    # TCP 플래그 One-Hot Encoding
    tcp_flags_list = ['F', 'S', 'R', 'P', 'A', 'U']
    def encode_flags(flags):
        flag_values = {flag: 1 if flag in flags else 0 for flag in tcp_flags_list}
        return pd.Series(flag_values)
    df_flags = df["flags"].apply(lambda x: encode_flags(str(x)))
    df = df.drop(columns=["flags"]).reset_index(drop=True)
    df = pd.concat([df, df_flags], axis=1)

    # 패킷 간 시간 차이 계산 및 정규화
    df["time_diff"] = df["frame_time"].diff().fillna(0)
    scaler_time = MinMaxScaler()
    df["time_diff"] = scaler_time.fit_transform(df[["time_diff"]])

    # 불필요한 컬럼 제거
    df.drop(columns=["frame_time"], inplace=True)
    return df

import numpy as np

def create_lstm_input(df, timesteps=10):
    X = []
    for i in range(len(df) - timesteps):
        X.append(df.iloc[i:i+timesteps].values)
    return np.array(X)

# 필요한 모듈
import numpy as np
import pandas as pd

# 시퀀스 누적용 리스트
X_all = []

# 파일 리스트
pcap_files =  [
    "/content/drive/MyDrive/Colab Notebooks/myfiles/TCP_8.pcap",
    "/content/drive/MyDrive/Colab Notebooks/myfiles/TCP_9.pcap",
    "/content/drive/MyDrive/Colab Notebooks/myfiles/flow1.pcap",
    "/content/drive/MyDrive/Colab Notebooks/myfiles/flow2.pcap",
    "/content/drive/MyDrive/Colab Notebooks/myfiles/flow3.pcap",
    "/content/drive/MyDrive/Colab Notebooks/myfiles/flow4.pcap"]
for pcap_file in pcap_files:
    print(f"Processing: {pcap_file}")

    # 1. 패킷 추출
    df = extract_tcp_features(pcap_file)
    if df.empty:
        print(f"{pcap_file} : 유효한 TCP 패킷 없음")
        continue

    # 2. 전처리
    preprocessed_df = preprocess_tcp_data(df)

    # 3. 시퀀스 생성
    X_seq = create_lstm_input(preprocessed_df, timesteps=10)

    # 4. 시퀀스 누적
    if len(X_seq) > 0:
        X_all.append(X_seq)
    else:
        print(f"{pcap_file} : 유효한 시퀀스 생성 안됨")

# 5. 최종 병합
if len(X_all) > 0:
    X_lstm_AE = np.concatenate(X_all, axis=0)
    print("LSTM 입력 데이터 형태:", X_lstm_AE.shape)
else:
    print("유효한 시퀀스가 없습니다.")
print(preprocessed_df.head(20))







